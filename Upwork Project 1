pip install opencv-python
pip install tesseract

# Packages
import cv2
import numpy as np
import pyautogui as pg
import pytesseract as pt
pt.pytesseract.tesseract_cmd = r'C:\Users\Matt\Documents\VMH\tesseract.exe'

# Templates
screenshot = pg.screenshot('screenshot.png')
base = cv2.imread('screenshot.png', cv2.IMREAD_UNCHANGED)
stone = cv2.imread('stone.png', cv2.IMREAD_UNCHANGED)
gold = cv2.imread('gold.png', cv2.IMREAD_UNCHANGED)
food = cv2.imread('food.png', cv2.IMREAD_UNCHANGED)
wood = cv2.imread('wood.png', cv2.IMREAD_UNCHANGED)
menu = cv2.imread('buff_menu.png', cv2.IMREAD_UNCHANGED)
gps = cv2.imread('gps1.png', cv2.IMREAD_UNCHANGED)

# Stone template match
result = cv2.matchTemplate(base, stone, cv2.TM_CCOEFF_NORMED)
# Fetch best match position
min_val, max_val, min_loc, max_loc = cv2.minMaxLoc(result)
# Painting box on image
w = stone.shape[1]
h = stone.shape[0]
cv2.rectangle(base, max_loc, (max_loc[0] + w, max_loc[1] + h), (0,255,255),2)
# Threshold
threshold = .60
# Boundaries
yloc, xloc = np.where(result >= threshold)
# Box control
for (x, y) in zip(xloc, yloc):
  cv2.rectangle(base, (x,y), (x + w, y + h), (0,255,255),2)
# What is a box?!?
# x, y, h, w
rectangles = []
for (x, y) in zip(xloc, yloc):  
  rectangles.append([int(x), int(y), int(w), int(h)])
rectangles, weights = cv2.groupRectangles(rectangles, 1, 0.2)
for (x, y, w, h) in rectangles:
  cv2.rectangle(base, (x,y), (x + w, y + h), (0,255,255),2)
  # Text identifier at box
  cv2.putText(base, 'stone', (x, y), cv2.FONT_HERSHEY_SIMPLEX, 0.9, (36,255,12),2)
# Flag status
stone_flag = False
for i in rectangles:
  if i.any() > threshold:
    stone_flag = True
    
# Gold template match
result = cv2.matchTemplate(base, gold, cv2.TM_CCOEFF_NORMED)
# Fetch best match position
min_val, max_val, min_loc, max_loc = cv2.minMaxLoc(result)
# Painting box on image
w = gold.shape[1]
h = gold.shape[0]
cv2.rectangle(base, max_loc, (max_loc[0] + w, max_loc[1] + h), (0,255,255),2)
# Threshold
threshold = .60
# Boundaries
yloc, xloc = np.where(result >= threshold)
# Box control
for (x, y) in zip(xloc, yloc):
  cv2.rectangle(base, (x,y), (x + w, y + h), (0,255,255),2)
# Are you sure this is a box?
# x, y, h, w
rectangles = []
for (x, y) in zip(xloc, yloc):  
  rectangles.append([int(x), int(y), int(w), int(h)])
rectangles, weights = cv2.groupRectangles(rectangles, 1, 0.2)
for (x, y, w, h) in rectangles:
  cv2.rectangle(base, (x,y), (x + w, y + h), (0,255,255),2)
  # Text identifier at box
  cv2.putText(base, 'gold', (x, y), cv2.FONT_HERSHEY_SIMPLEX, 0.9, (36,255,12),2)
# Flag status
gold_flag = False
for i in rectangles:
  if i.any() > threshold:
    gold_flag = True
    
# Gold template match
result = cv2.matchTemplate(base, food, cv2.TM_CCOEFF_NORMED)
# Fetch best match position
min_val, max_val, min_loc, max_loc = cv2.minMaxLoc(result)
# Painting box on image
w = food.shape[1]
h = food.shape[0]
cv2.rectangle(base, max_loc, (max_loc[0] + w, max_loc[1] + h), (0,255,255),2)
# Threshold
threshold = .60
# Boundaries
yloc, xloc = np.where(result >= threshold)
# Box control
for (x, y) in zip(xloc, yloc):
  cv2.rectangle(base, (x,y), (x + w, y + h), (0,255,255),2)
# I don't know, it might be a bag?
# x, y, h, w
rectangles = []
for (x, y) in zip(xloc, yloc):  
  rectangles.append([int(x), int(y), int(w), int(h)])
rectangles, weights = cv2.groupRectangles(rectangles, 1, 0.2)
for (x, y, w, h) in rectangles:
  cv2.rectangle(base, (x,y), (x + w, y + h), (0,255,255),2)
  # Text identifier at box
  cv2.putText(base, 'food', (x, y), cv2.FONT_HERSHEY_SIMPLEX, 0.9, (36,255,12),2)
# Flag status
food_flag = False
for i in rectangles:
  if i.any() > threshold:
    food_flag = True
    
 # Template match
result = cv2.matchTemplate(base, wood, cv2.TM_CCOEFF_NORMED)
# Fetch best match position
min_val, max_val, min_loc, max_loc = cv2.minMaxLoc(result)
# Painting box on image
w = wood.shape[1]
h = wood.shape[0]
cv2.rectangle(base, max_loc, (max_loc[0] + w, max_loc[1] + h), (0,255,255),2)
# Threshold
threshold = .60
# Boundaries
yloc, xloc = np.where(result >= threshold)
# Box control
for (x, y) in zip(xloc, yloc):
  cv2.rectangle(base, (x,y), (x + w, y + h), (0,255,255),2)
# I don't know, it might be a bag?
# x, y, h, w
rectangles = []
for (x, y) in zip(xloc, yloc):  
  rectangles.append([int(x), int(y), int(w), int(h)])
rectangles, weights = cv2.groupRectangles(rectangles, 1, 0.2)
for (x, y, w, h) in rectangles:
  cv2.rectangle(base, (x,y), (x + w, y + h), (0,255,255),2)
  # Text identifier at box
  cv2.putText(base, 'wood', (x, y), cv2.FONT_HERSHEY_SIMPLEX, 0.9, (36,255,12),2)
# Flag status
wood_flag = False
for i in rectangles:
  if i.any() > threshold:
    wood_flag = True
    
# Node located check->click
while gold_flag == True:
  # Randomization
  selVar1 = np.random.randint(1, 5)
  selVar2 = np.random.randint(5, 7)
  # Locate object
  x,y= pg.locateCenterOnScreen('gold.png', confidence = 0.6)
  # Click on object
  pg.click(x=x+selVar1,y=y-selVar2)
  break
while food_flag == True:
  # Randomization
  selVar1 = np.random.randint(1, 5)
  selVar2 = np.random.randint(5, 7)
  # Locate object
  x,y= pg.locateCenterOnScreen('food.png', confidence = 0.6)
  pg.click(x=x+selVar1,y=y-selVar2)
  break
while wood_flag == True:
  # Randomization
  selVar1 = np.random.randint(1, 5)
  selVar2 = np.random.randint(5, 7)
  # Locate object
  x,y= pg.locateCenterOnScreen('wood.png', confidence = 0.6)
  # Click on object
  pg.click(x=x+selVar1,y=y-selVar2)
while stone_flag == True:
  # Randomization
  selVar1 = np.random.randint(1, 5)
  selVar2 = np.random.randint(5, 7)
  # Locate object
  x, y= pg.locateCenterOnScreen('stone.png', confidence = 0.6)
  # Click on object
  pg.click(x=x+selVar1,y=y-selVar2)
  
  def extraction():
# Read image from which text needs to be extracted
    img = cv2.imread("gps.png")
# Preprocessing the image starts
# Convert the image to gray scale
    gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)
# Performing OTSU threshold
    ret, thresh1 = cv2.threshold(gray, 0, 255, cv2.THRESH_OTSU | cv2.THRESH_BINARY_INV)
# Specify structure shape and kernel size.
# Kernel size increases or decreases the area
# of the rectangle to be detected.
# A smaller value like (10, 10) will detect
# each word instead of a sentence.
    rect_kernel = cv2.getStructuringElement(cv2.MORPH_RECT, (18, 18))
# Applying dilation on the threshold image
    dilation = cv2.dilate(thresh1, rect_kernel, iterations = 1)
# Finding contours
    contours, hierarchy = cv2.findContours(dilation, cv2.RETR_EXTERNAL,
                                                 cv2.CHAIN_APPROX_NONE)
# Creating a copy of image
    im2 = img.copy()
# A text file is created and flushed
    file = open("recognized.txt", "w+")
    file.write("")
    file.close()
# Looping through the identified contours
# Then rectangular part is cropped and passed on
# to pytesseract for extracting text from it
# Extracted text is then written into the text file
    for cnt in contours:
        x, y, w, h = cv2.boundingRect(cnt)  
    # Drawing a rectangle on copied image
        rect = cv2.rectangle(im2, (x, y), (x + w, y + h), (0, 255, 0), 2)   
    # Cropping the text block for giving input to OCR
        cropped = im2[y:y + h, x:x + w]   
    # Open the file in append mode
        file = open("recognized.txt", "a")    
    # Apply OCR on the cropped image
        text = pt.image_to_string(cropped)  
    # Appending the text into file
    file.write(text)
    file.write("\n")  
    # Close the file
    file.close
